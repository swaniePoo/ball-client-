package me.dinozoid.strife.module.implementations.exploit;

import me.dinozoid.strife.alpine.event.EventState;
import me.dinozoid.strife.alpine.listener.EventHandler;
import me.dinozoid.strife.alpine.listener.Listener;
import me.dinozoid.strife.event.implementations.network.PacketInboundEvent;
import me.dinozoid.strife.event.implementations.player.PlayerMotionEvent;
import me.dinozoid.strife.event.implementations.player.WorldLoadEvent;
import me.dinozoid.strife.event.implementations.render.Render3DEvent;
import me.dinozoid.strife.module.Category;
import me.dinozoid.strife.module.Module;
import me.dinozoid.strife.module.ModuleInfo;
import me.dinozoid.strife.util.pathfinder.Node;
import me.dinozoid.strife.util.pathfinder.PathFinder;
import me.dinozoid.strife.util.player.ChatFormatting;
import me.dinozoid.strife.util.player.MovementUtil;
import me.dinozoid.strife.util.player.PlayerUtil;
import me.dinozoid.strife.util.player.RotationUtil;
import me.dinozoid.strife.util.render.RenderUtil;
import me.dinozoid.strife.util.system.TimerUtil;
import me.dinozoid.strife.util.world.WorldUtil;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.item.EntityArmorStand;
import net.minecraft.network.play.server.S02PacketChat;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;
import net.minecraft.util.BlockPos;
import org.lwjgl.opengl.GL11;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@ModuleInfo(name = "ParkourGame", renderName = "ParkourGame", category = Category.EXPLOIT)
public class ParkourGameModule extends Module {

    ArrayList<Node> path = new ArrayList<>();
    private PathFinder pathFinder;
    @EventHandler
    public final Listener<Render3DEvent> render3DEventListener = new Listener<>(event -> {
        try {
            if (pathFinder != null) {
                GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
                GL11.glEnable(GL11.GL_BLEND);
                GL11.glEnable(GL11.GL_LINE_SMOOTH);
                GL11.glLineWidth(2f);
                GL11.glDisable(GL11.GL_TEXTURE_2D);
                GL11.glDisable(GL11.GL_DEPTH_TEST);
                GL11.glDepthMask(false);
                GL11.glBegin(GL11.GL_LINES);
                for (Node n : path) {
                    if (path.indexOf(n) <= 0) {
                        continue;
                    }
                    Node n1 = path.get(path.indexOf(n) - 1);
                    float x = (float) (RenderUtil.interpolate(n.getX(), n.getX(), event.getPartialTicks()) - mc.getRenderManager().viewerPosX);
                    float y = (float) (RenderUtil.interpolate(n.getY(), n.getY(), event.getPartialTicks()) - mc.getRenderManager().viewerPosY);
                    float z = (float) (RenderUtil.interpolate(n.getZ(), n.getZ(), event.getPartialTicks()) - mc.getRenderManager().viewerPosZ);
                    float x1 = (float) (RenderUtil.interpolate(n1.getX(), n1.getX(), event.getPartialTicks()) - mc.getRenderManager().viewerPosX);
                    float y1 = (float) (RenderUtil.interpolate(n1.getY(), n1.getY(), event.getPartialTicks()) - mc.getRenderManager().viewerPosY);
                    float z1 = (float) (RenderUtil.interpolate(n1.getZ(), n1.getZ(), event.getPartialTicks()) - mc.getRenderManager().viewerPosZ);
                    drawLine(x + 0.5, y + 0.5, z + 0.5, x1 + 0.5, y1 + 0.5, z1 + 0.5);
                }
                GL11.glEnd();
                GL11.glEnable(GL11.GL_TEXTURE_2D);
                GL11.glDisable(GL11.GL_LINE_SMOOTH);
                GL11.glEnable(GL11.GL_DEPTH_TEST);
                GL11.glDepthMask(true);
                GL11.glDisable(GL11.GL_BLEND);
                GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    });
    private int teleportTicks = 0;
    private int checkpoint;
    private final Map<Integer, BlockPos> checkpointMap = new HashMap<>();
    @EventHandler
    public final Listener<WorldLoadEvent> worldLoadListener = new Listener<>(event -> {
        checkpoint = 0;
        teleportTicks = 20;
        checkpointMap.clear();
        toggle();
    });
    @EventHandler
    private final Listener<PacketInboundEvent> packetInboundListener = new Listener<>(event -> {
        if (event.getPacket() instanceof S08PacketPlayerPosLook && checkpoint < checkpointMap.size()) {
            S08PacketPlayerPosLook look = event.getPacket();
            teleportTicks = 20;
//            pathFinder.setStart(new Node(look.getX(), look.getY(), look.getZ()));
        }
        if (event.getPacket() instanceof S02PacketChat) {
            S02PacketChat chat = event.getPacket();
            if (!chat.isChat()) {
                String text = ChatFormatting.stripFormatting(chat.getChatComponent().getUnformattedText());
                if (text.contains("You reached checkpoint")) {
                    text = text.substring(text.indexOf("reached checkpoint ") + "reached checkpoint ".length()).substring(0, 1);
                    int checkpoint = -1;
                    try {
                        checkpoint = Integer.parseInt(text);
                    } catch (Exception ignored) {
                    }
                    if (checkpoint != -1) this.checkpoint = checkpoint;
                }
            }
        }
    });
    private double teleportX, teleportY, teleportZ;
    private final TimerUtil timer = new TimerUtil();
    @EventHandler
    private final Listener<PlayerMotionEvent> updatePlayerListener = new Listener<>(event -> {
        if (event.getState() == EventState.PRE) {
            path.clear();
//            pathFinder.setStart(new Node(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ));
            List<EntityLivingBase> entities = WorldUtil.getLivingEntities(entity -> entity instanceof EntityArmorStand);
            entities.forEach(entity -> {
                if (entity != null && entity.hasCustomName()) {
                    String name = ChatFormatting.stripFormatting(entity.getDisplayName().getUnformattedText());
                    if (!name.contains("#")) return;
                    name = name.replace("#", "");
                    int checkpoint = -1;
                    try {
                        checkpoint = Integer.parseInt(name);
                    } catch (Exception ignored) {
                    }
                    if (checkpoint != -1 && !checkpointMap.containsKey(checkpoint - 1) && entity.getPosition() != null) {
                        BlockPos position = entity.getPosition();
                        checkpointMap.put(checkpoint - 1, position);
                        PlayerUtil.sendMessageWithPrefix("Added Checkpoint #" + checkpoint + " at Position: " + position);
                    }
                }
            });
        } else {
            BlockPos position = checkpointMap.get(checkpoint);
            if (position != null) {
                pathFinder.setDestination(new Node(position.getX(), position.getY() + 2, position.getZ()));
                pathFinder = new PathFinder(new Node(mc.thePlayer.posX, mc.thePlayer.posY + 1, mc.thePlayer.posZ), new Node(position.getX(), position.getY() + 3, position.getZ()));
                if(pathFinder.getStart() == null) return;
                path = pathFinder.getPath(500);
                if (teleportTicks > 0) {
                    if (path != null && !(path.size() <= 1)) {
                        Node node = path.get(0);
                        MovementUtil.setSpeed(MovementUtil.getBaseMoveSpeed() * 10, 1, mc.thePlayer.movementInput.moveStrafe, RotationUtil.getRotationFromPosition(node.getX(), node.getY(), node.getZ())[0]);
                        mc.thePlayer.motionY = (node.getY() - mc.thePlayer.posY) / 2;
                        timer.reset();
                        PlayerUtil.sendMessageWithPrefix("Teleported to Checkpoint #" + (checkpoint + 1));
                    }
                    if (mc.thePlayer.getPosition().equals(position)) {
                        if (timer.hasElapsed(500)) {
                            teleportTicks = 0;
                        }
                    }
                }
            }
            if (teleportTicks > 0) teleportTicks--;
        }
    });

    public void drawLine(double x, double y, double z, double x1, double x2, double x3) {
        GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
        GL11.glVertex3d(x, y, z);
        GL11.glVertex3d(x1, x2, x3);
    }

    @Override
    public void onEnable() {
        super.onEnable();
        pathFinder = new PathFinder();
        pathFinder.setStart(new Node(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ));
    }

    @Override
    public void onDisable() {
        super.onDisable();
        checkpoint = 0;
        teleportTicks = 0;
        checkpointMap.clear();
    }

}